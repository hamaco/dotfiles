" === Startup ===
" https://gist.github.com/1518874
if has('vim_starting') && has('reltime')
  let g:startuptime = reltime()
  augroup vimrc-startuptime
    autocmd! VimEnter * let g:startuptime = reltime(g:startuptime) | redraw
    \ | echomsg 'startuptime: ' . reltimestr(g:startuptime)
  augroup END
endif


if has('vim_starting')
  set runtimepath& runtimepath+=$HOME/.vim
endif

let s:is_win = has('win32') || has('win64')
if s:is_win
  language messages en
endif

let g:vim_indent_cont = 0
let mapleader = ","

" === My functions ===
function! s:source_if(file)
  let realpath = expand(a:file)

  if filereadable(realpath)
    source `=realpath`
  endif
endfunction

function! MyStatusLine()
  let line  = ''

  let line .= '%<' " Truncate point
  let line .= '%f' " Filename
  let line .= '%m' " Modified flag
  let line .= ' %{cfi#format("<%s()>", "")}' " current-func-info.vim
  let line .= '%=' " Separation point
  let line .= '%y' " Filetype
  let line .= '%r' " Readonly flag
  let line .= '[%{&l:fenc}:%{&ff}]' " File encoding and format
  let line .= '  %-10.(%l,%c%V%)' " Current line status
  let line .= '%P' " Percentage through file of displayed window

  return line
endfunction

" === Load plugins ===
call s:source_if('~/.vim/neobundle.vimrc')

syntax enable
colorscheme jellybeans


" === Settings ===

" ===== Encoding =====
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=ucs-bom,utf-8,iso-2022-jp,euc-jp,cp932
set fileformat=unix
set fileformats=unix,dos,mac

" ===== Backup =====
set backup backupcopy=yes backupdir=~/.vimbackup
set swapfile directory=~/.vimbackup
if !isdirectory(&backupdir)
  call mkdir(&backupdir, "p")
endif
if has('persistent_undo')
  set undodir=~/.vimbackup
  set undofile
endif


" Vim 以外の所でファイルが変更された場合自動で読み込む
set autoread
set ambiwidth=double
set backspace=indent,eol,start
set clipboard=unnamed
set formatoptions& formatoptions-=ro formatoptions+=mM
set helplang=ja,en
set keywordprg=:help
set laststatus=2 statusline=%!MyStatusLine()
set showtabline=2
set ignorecase smartcase incsearch hlsearch
set imdisable
set nrformats=hex
set list listchars=tab:»-,trail:-,eol:↲,extends:»,precedes:«,nbsp:%
"set pastetoggle=<C-e>
set nomore
set showcmd showmode
set wildmenu wildmode=list:longest
set splitbelow splitright
set novisualbell t_vb=
set conceallevel=2 concealcursor=i
set title
set number
set completeopt-=preview

" set autoindent
set expandtab
set tabstop=2
set softtabstop=2
set shiftwidth=2
set shiftround


" === autocmd ===
command! -bang -nargs=* Autocmd autocmd<bang> vimrc <args>
augroup vimrc
  autocmd!
augroup END

Autocmd FileType git-diff,help,quickrun,quickfix,qf,ref,vcs-status nnoremap <buffer> q <C-w>c


" === command ===
" 文字コードを変えて最読込
command! -nargs=? -bang -complete=file Utf8 edit<bang> ++enc=utf-8  <args>
command! -nargs=? -bang -complete=file Euc  edit<bang> ++enc=euc-jp <args>
command! -nargs=? -bang -complete=file Sjis edit<bang> ++enc=cp932  <args>

" 文字コードを変換
command! -nargs=0 ToUtf8    setlocal fileencoding=utf-8
command! -nargs=0 ToEuc     setlocal fileencoding=euc-jp
command! -nargs=0 ToSjis    setlocal fileencoding=cp932
command! -nargs=0 ToWindows setlocal fileencoding=cp932 fileformat=dos
command! -nargs=0 ToUnix    setlocal fileencoding=utf-8 fileformat=unix

command! -nargs=1 -bang -complete=file Rename saveas<bang> <args> | call delete(expand('#:p'))
command! RemoveTrailingSpaces %s/\s\+$// | nohlsearch
command! RemoveBlankLines :g /^$/d


" === Key mappings ===
nnoremap <Leader>ev :<C-u>tabedit $MYVIMRC<CR>
nnoremap <Leader>eg :<C-u>tabedit $MYGVIMRC<CR>

noremap ; :
noremap : ;

nnoremap j gj
nnoremap k gk

inoremap <C-b> <Left>
inoremap <C-f> <Right>

cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>

nnoremap q <Nop>
nnoremap Q q

nnoremap Y y$

" Very magic
nnoremap / /\v
nnoremap ? ?\v

" ウィンドウ
nnoremap <Tab> <C-w>w

" タブ
nnoremap <C-t> <Nop>
nnoremap <C-t>o :<C-u>tabonly<CR>
nnoremap <silent> <Left> :<C-u>execute 'tabmove' tabpagenr() - 2<CR>
nnoremap <silent> <Right> :<C-u>execute 'tabmove' tabpagenr()<CR>

nnoremap vv <C-v>
noremap! <C-BS> <C-w>

cnoremap <C-x> <C-r>=expand("%:p:h")<CR>/

cnoremap <expr> / getcmdtype() == '/' ? '\/' : '/'
cnoremap <expr> ? getcmdtype() == '?' ? '\?' : '?'

nnoremap <Leader>a ggVG

" 括弧までの選択を簡単にする
onoremap ) f)
onoremap ( t(
vnoremap ) f)
vnoremap ( t(


" === Plugin settings ===

" alignta.vim
if neobundle#tap('vim-alignta')
  vnoremap <Leader>a :Alignta<Space>

  call neobundle#untap()
endif


" altercmd.vim
if neobundle#tap('vim-altercmd')
  call altercmd#load()
  command! -bar -nargs=+ MapAlterCommand CAlterCommand <args> | AlterCommand <cmdwin> <args>

  MapAlterCommand t[abedit]  tabedit

  MapAlterCommand sl setl
  MapAlterCommand sf setf

  call neobundle#untap()
endif


" anzu.vim
let g:anzu_search_limit = 250

nmap n <Plug>(anzu-n)
nmap N <Plug>(anzu-N)
nmap * <Plug>(anzu-star)
nmap # <Plug>(anzu-sharp)


" autochmodx.vim
let g:autochmodx_ignore_scriptish_file_patterns = [
\ '\c.*\.rb$',
\]


" ===== autodirmake.vim =====
if neobundle#tap('autodirmake.vim')
  let g:autodirmake#is_confirm = 0

  call neobundle#untap()
endif


" automatic.vim
if neobundle#tap('vim-automatic')
  function! neobundle#tapped.hooks.on_source(bundle)
    let g:automatic_config = []
    call add(g:automatic_config, {
    \   'match' : {
    \       'localtime_expr' : '6 <= hour && hour <= 11',
    \       'autocmds' : ['VimEnter'],
    \       'is_open_other_window' : 0
    \   },
    \   'set' : {
    \       'pronamachang_voice' : 'kei_voice_008',
    \   },
    \ })

    call add(g:automatic_config, {
    \   'match' : {
    \       'localtime_expr' : '12 <= hour && hour <= 18',
    \       'autocmds' : ['VimEnter'],
    \       'is_open_other_window' : 0
    \   },
    \   'set' : {
    \       'pronamachang_voice' : 'kei_voice_009',
    \   },
    \ })

    call add(g:automatic_config, {
    \   'match' : {
    \       'localtime_expr' : '19 <= hour && hour <= 23',
    \       'autocmds' : ['VimEnter'],
    \       'is_open_other_window' : 0
    \   },
    \   'set' : {
    \       'pronamachang_voice' : 'kei_voice_010',
    \   },
    \ })


    call add(g:automatic_config, {
    \   'match' : {
    \       'bufname' : '\[unite\]',
    \       'unite_sources' : ['grep']
    \   },
    \   'set' : {
    \       'pronamachang_voice' : 'kei_voice_036_phrase1',
    \   },
    \})
  endfunction

  call neobundle#untap()
endif


" calendar.vim
let g:calendar_google_calendar = 1


" caw.vim
nmap gc <Plug>(caw:prefix)
vmap gc <Plug>(caw:prefix)


" clever-f.vim
if neobundle#tap('clever-f.vim')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    let g:clever_f_smart_case = 1
    " fhでbとかfとかにマッチしちゃったのでmigemoはOFF
    let g:clever_f_use_migemo = 0
    let g:clever_f_chars_match_any_signs = ';'
  endfunction

  call neobundle#untap()
endif

" editorconfig.vim
let g:EditorConfig_verbose = 1


" eskk.vim
if neobundle#tap('eskk.vim')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    let g:eskk#dictionary = '~/.skk-jisyo'

    if has('mac')
      let g:eskk#large_dictionary = expand('~/Library/Application\ Support/AquaSKK/SKK-JISYO.L')
    elseif has('unix')
      let g:eskk#large_dictionary = expand('/usr/share/skk/SKK-JISYO.L')
    elseif s:is_win
      let g:eskk#large_dictionary = expand('~/SKK-JISYO.L')
    endif
  endfunction

  " なんかあんまり辞書登録ちゃんとされてる気がしないので毎回書き込んでみる
  let g:eskk#dictinary_save_count = 1
  let g:eskk#egg_like_newline = 1
  let g:eskk#egg_like_newline_completion = 1

  call neobundle#untap()
endif


" fugitive.vim
if neobundle#tap('vim-fugitive')
  nnoremap <Leader>gd :<C-u>Gdiff<Enter>
  nnoremap <Leader>gs :<C-u>Gstatus<Enter>
    nnoremap <Leader>gl :<C-u>Glog<Enter>
  nnoremap <Leader>ga :<C-u>Gwrite<Enter>
  nnoremap <Leader>gc :<C-u>Gcommit<Enter>
    nnoremap <Leader>gC :<C-u>Git commit --amend<Enter>
    nnoremap <Leader>gb :<C-u>Gblame<Enter>
endif


" gist.vim
let g:gist_update_on_write = 2


" ===== gitv.vim =====
Autocmd FileType git :setl foldlevel=99
Autocmd FileType gitv call s:my_gitv_settings()
function! s:my_gitv_settings()
  setlocal iskeyword+=/,-,.
  nnoremap <silent><buffer> C :<C-u>Git checkout <C-r><C-w><CR>
endfunction


" indenthtml.vim
if neobundle#tap('indenthtml.vim')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    let g:html_indent_inctags = 'html,body,head,tbody,p,li,dt'
  endfunction

  call neobundle#untap()
endif


" lightline.vim
let g:lightline = {
\   'colorscheme': 'wombat',
\   'active': {
\       'left': [
\           ['mode', 'paste'],
\           ['readonly', 'fugitive', 'filename', 'cfi', 'modified', 'anzu'],
\       ],
\       'right': [
\           ['lineinfo'],
\           ['percent'],
\           ['fileformat', 'fileencoding', 'filetype']
\       ],
\   },
\   'component_function': {
\       'anzu':      'anzu#search_status',
\       'cfi':       'MyCurrentFuncInfo',
\       'fugitive':  'MyFugitive',
\   }
\ }

function! MyFugitive()
  return exists('*fugitive#head') ? fugitive#head() : ''
endfunction

function! MyCurrentFuncInfo()
  return ''
  return cfi#format("::%s()", "")
endfunction


" neocomplete.vim
if neobundle#tap('neocomplete')
  let g:neocomplete#enable_at_startup = 1
  let g:neocomplete#enable_ignore_case = 0
  let g:neocomplete#enable_smart_case = 1

  let g:neocomplete#sources#buffer#disabled_pattern = '\.log'

  let g:neocomplete#sources#syntax#min_keyword_length = 2

  let g:neobomplete#sources#dictionary#dictionaries = {
  \   'default': '',
  \   'vimshell': $HOME.'/.vimshell/command-history',
  \ }

  if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
  endif
  let g:neocomplete#keyword_patterns['default'] = '\h\w*'

  if !exists('g:neocomplete#sources#omni#input_patterns')
    let g:neocomplete#sources#omni#input_patterns = {}
  endif
  let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'

  call neobundle#untap()
endif


" neosnippet.vim
if neobundle#tap('neosnippet')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    imap <C-k> <Plug>(neosnippet_expand_or_jump)
    smap <C-k> <Plug>(neosnippet_expand_or_jump)

    imap <expr> <TAB> neosnippet#expandable() <Bar><Bar> neosnippet#jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)" :
    \ pumvisible() ? "\<C-n>" : "\<TAB>"
  endfunction

  let g:neosnippet#snippets_directory = "~/.vim/snippets"

  call neobundle#untap()
endif


" octoeditor.vim
if neobundle#tap('octoeditor.vim')
  function! neobundle#tapped.hooks.on_source(bundle)
    let g:octopress_path = '~/works/octopress-github'
  endfunction

  call neobundle#untap()
endif


" open-browser.vim
if neobundle#tap('open-browser.vim')
  nmap gx <Plug>(openbrowser-smart-search)
  vmap gx <Plug>(openbrowser-smart-search)

  call neobundle#untap()
endif


" operator-replace.vim
map R <Plug>(operator-replace)


" pronamachang
let g:pronamachang_voice_root = "/Users/hamaco/Desktop"


" vim-precious
map <Leader>q <Plug>(precious-quickrun-op)
omap ic <Plug>(textobj-precious-i)
vmap ic <Plug>(textobj-precious-i)

let g:precious_enable_switch_CursorMoved = {
\   'help': 0
\ }


" quickrun.vim
let g:quickrun_config = {}
let g:quickrun_config['_'] = {
\   'runner': 'vimproc',
\   'runner/vimproc/updatetime': 100,
\   'outputter': 'multi:buffer:quickfix',
\   'outputter/buffer/split': ':botright 8sp',
\   'hook/close_buffer/enable_failure': 1,
\   'outputter/quickfix/open_cmd': '',
\   'hook/unite_quickfix/enable_failure': 1,
\   'hook/close_unite_quickfix/enable_hook_loaded': 1,
\   'hook/time/enable': 1,
\   'hook/u_nya_/enable': 1,
\   'hook/quickfix_replate_tempname_to_bufnr/enable_exit' : 1,
\   'hook/quickfix_replate_tempname_to_bufnr/priority_exit' : -10,
\ }

if has('mac')
  let g:quickrun_config['markdown'] = {
  \   'outputter': 'null',
  \   'command':   'open',
  \   'cmdopt':    '-a',
  \   'args':      'Marked',
  \   'exec':      '%c %o %a %s',
  \ }
else
  let g:quickrun_config['markdown'] = {
  \   'outputter': 'multi',
  \   'outputter/multi/targets': ['buffer', 'browser']
  \ }
endif

let g:quickrun_config['watchdogs_checker/_'] = {
\   'outputter/quickfix/open_cmd': '',
\   'hook/unite_quickfix/enable_failure': 1,
\   'hook/u_nya_/enable': 0,
\ }

augroup QuickRunPHPUnit
  autocmd!
  autocmd BufWinEnter,BufNewFile *Test.php  set filetype=php.phpunit
  autocmd BufWinEnter,BufNewFile *_test.php set filetype=php.phpunit
augroup END
let g:quickrun_config['php.phpunit'] = {
\   'command': 'phpunit',
\   'outputter': 'phpunit',
\   'hook/close_buffer/enable_failure': 0,
\   'hook/close_quickfix/enable_exit': 0,
\   'hook/unite_quickfix/enable_failure': 0,
\ }


" ref.vim
if neobundle#tap('vim-ref')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    let g:ref_use_vimproc = 1
    let g:ref_phpmanual_path = $HOME . '/share/phpmanual'

    let g:ref_source_webdict_sites = {
    \   'default': 'alc',
    \   'alc': {
    \     'url': 'http://eow.alc.co.jp/search?q=%s',
    \   },
    \   'wikipedia:ja': 'http://ja.wikipedia.org/wiki/%s',
    \ }
    function! g:ref_source_webdict_sites.alc.filter(output)
      return join(split(a:output, "\n")[38 :], "\n")
    endfunction
  endfunction

  noremap <Space>ra :<C-u>Ref webdict alc<Space>
  noremap <Space>rm :<C-u>Ref man<Space>

  call neobundle#untap()
endif


" ===== restart.vim =====
if neobundle#tap('restart.vim')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    command!
    \   -bar
    \   RestartWithSession
    \   let g:restart_sessionoptions = 'blank,curdir,folds,help,localoptions,tabpages'
    \   | Restart
  endfunction

  MapAlterCommand res[tart] Restart

  call neobundle#untap()
endif


" ===== smartinput.vim =====
if neobundle#tap('vim-smartinput')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    call smartinput#map_to_trigger('i', '<Space>', '<Space>', '<Space>')
    call smartinput#map_to_trigger('i', '<', '<', '<')
    call smartinput#map_to_trigger('i', '>', '>', '>')
    call smartinput#map_to_trigger('i', '%', '%', '%')
    call smartinput#map_to_trigger('i', '?', '?', '?')
    call smartinput#map_to_trigger('i', '-', '-', '-')
    call smartinput#map_to_trigger('i', '<Plug>(vimrc_cr)', '<Enter>', '<Enter>')

    imap <expr><CR> !pumvisible() ? "\<Plug>(vimrc_cr)" :
    \    neosnippet#expandable() ? "\<Plug>(neosnippet_expand)" :
    \    neocomplete#smart_close_popup() . "\<CR>"

    call smartinput#define_rule({'at': '^\s*\%#', 'char': '-', 'input': '-<Space>', 'filetype': ['markdown']})
    call smartinput#define_rule({'at': '- \%#', 'char': '[', 'input': '[<Space>]<Space>', 'filetype': ['markdown']})

    call smartinput#define_rule({
    \    'at'       : 'eval\s*\%#',
    \    'char'     : '{',
    \    'input'    : '{};<Left><Left>',
    \    'filetype' : ['perl'],
    \ })

    " call smartinput#define_rule({'at': '\%#', 'char': '<', 'input': '<><Left>'})
    " call smartinput#define_rule({'at': '\%#\_s*>', 'char': '>', 'input': '<C-r>=smartinput#_leave_block(''>'')<Enter><Right>'})
    " call smartinput#define_rule({'at': '<\%#>', 'char': '<BS>', 'input': '<BS><Del>'})
    " call smartinput#define_rule({'at': '<\%#>', 'char': '<', 'input': '<<Del>'})
    " call smartinput#define_rule({'at': '<<\%#', 'char': '<', 'input': '<'})

    " perl Template-Toolkit
    call smartinput#define_rule({'at': '\[\%#\]', 'char': '<Space>', 'input': '<Space><Space><Left>'})
    call smartinput#define_rule({'at': '\[\%#\]', 'char': '%', 'input': '%<Space><Space>%<Left><Left>'})
    call smartinput#define_rule({'at': '\[% \%# %\]', 'char': '<BS>', 'input': '<BS><BS><Del><Del>'})

    " PHP Twig
    call smartinput#define_rule({'at': '{\%#}', 'char': '<Space>', 'input': '<Space><Space><Left>'})
    call smartinput#define_rule({'at': '{\%#}', 'char': '%', 'input': '%<Space><Space>%<Left><Left>'})
    call smartinput#define_rule({'at': '{% \%# %}', 'char': '<BS>', 'input': '<BS><BS><Del><Del>'})
    call smartinput#define_rule({'at': '{\%#}', 'char': '{', 'input': '{<Space><Space>}<Left><Left>'})
    call smartinput#define_rule({'at': '{{ \%# }}', 'char': '<BS>', 'input': '<BS><BS><Del><Del>'})

    " PHP
    call smartinput#define_rule({'at': '<\%#>', 'char': '?', 'input': '?<Space>?<Left><Left>'})
    call smartinput#define_rule({'at': '<?\%# ?>', 'char': '<BS>', 'input': '<BS><Del><Del>'})
  endfunction
endif

imap <C-j> <Plug>(eskk:toggle)
cmap <C-j> <Plug>(eskk:toggle)


" ===== simple-javascript-indenter.vim =====
if neobundle#tap('simple-javascript-indenter')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    let g:SimpleJsIndenter_BriefMode = 1
  endfunction

  call neobundle#untap()
endif


" ===== smartword.vim =====
if neobundle#tap('vim-smartword')
  map w <Plug>(smartword-w)
  map b <Plug>(smartword-b)
  map e <Plug>(smartword-e)
  map ge <Plug>(smartword-ge)

  noremap W w
  noremap B b
  noremap E e
  noremap gE ge

  call neobundle#untap()
endif


" ===== sonictemplate.vim =====
let g:sonictemplate_vim_template_dir = expand('~/.vim/templates/')
MapAlterCommand te[mplate] Template


" ===== submode.vim =====
if neobundle#tap('vim-submode')
  let g:submode_keep_leaving_key = 1

  " タブの切り替え
  call submode#enter_with('tabpage', 'n', '', 'gt', 'gt')
  call submode#enter_with('tabpage', 'n', '', 'gT', 'gT')
  call submode#map('tabpage', 'n', '', 't', 'gt')
  call submode#map('tabpage', 'n', '', 'T', 'gT')

  " ウィンドウのリサイズ
  call submode#enter_with('winsize', 'n', '', '<C-w>>', '<C-w>>')
  call submode#enter_with('winsize', 'n', '', '<C-w><', '<C-w><')
  call submode#enter_with('winsize', 'n', '', '<C-w>+', '<C-w>+')
  call submode#enter_with('winsize', 'n', '', '<C-w>-', '<C-w>-')
  call submode#map('winsize', 'n', '', '>', '<C-w>>')
  call submode#map('winsize', 'n', '', '<', '<C-w><')
  call submode#map('winsize', 'n', '', '+', '<C-w>+')
  call submode#map('winsize', 'n', '', '-', '<C-w>-')

  call neobundle#untap()
endif


" ===== switch.vim =====
if neobundle#tap('switch.vim')
  nnoremap - :<C-u>Switch<CR>

  call neobundle#untap()
endif


" ===== tagbar.vim =====
if neobundle#tap('tagbar')
  nnoremap <silent> <Leader>t :<C-u>TagbarToggle<CR>

  call neobundle#untap()
endif


" ===== tmpwin.vim =====
nnoremap <silent><Leader>tt :<C-u>call tmpwin#toggle(
\   {'open' : '15split', 'move_cursor': 1},
\   'TweetVimHomeTimeline')<CR>


" ===== unite.vim =====
if neobundle#tap('unite.vim')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    let g:unite_source_history_yank_enable = 1

    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = '--nocolor --nogroup --column'
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_max_candidates = 200

    call unite#custom#alias('file', 'tabopen', 'tabdrop')
    call unite#custom#alias('directory', 'tabopen', 'tabvimfiler')

    Autocmd FileType unite call s:unite_my_settings()
    function! s:unite_my_settings()
      nmap <buffer> <ESC> <Plug>(unite_exit)
      imap <buffer> jj <Plug>(unite_insert_leave)
      nmap <buffer> ' <Plug>(unite_quick_match_default_action)
      imap <buffer> ' <Plug>(unite_quick_match_default_action)
      nmap <buffer> x <Plug>(unite_toggle_mark_current_candidate)
      imap <buffer> <C-BS> <Plug>(unite_delete_backward_path)
    endfunction
  endfunction

  nnoremap [unite] <Nop>
  nmap ,f [unite]

  noremap <silent> [unite]b :<C-u>UniteWithBufferDir -buffer-name=files -start-insert file file/new<CR>
  noremap <silent> [unite]c :<C-u>Unite -auto-preview colorscheme<CR>
  noremap <silent> [unite]g :<C-u>Unite grep:. -buffer-name=search -auto-preview -no-quit<CR>
  noremap <silent> [unite]G :<C-u>Unite grep:. -buffer-name=search -auto-preview -no-quit<CR><C-r><C-w>
  noremap <silent> [unite]I :<C-u>Unite -auto-quit neobundle/update<CR>
  noremap <silent> [unite]j :<C-u>Unite -default-action=vimfiler bookmark<CR>
  noremap <silent> [unite]o :<C-u>Unite outline<CR>
  noremap <silent> [unite]u :<C-u>Unite -buffer-name=files -start-insert buffer file_rec/async:! file file_mru<CR>

  call neobundle#untap()
endif


" ===== vimfiler.vim =====
let g:vimfiler_as_default_explorer = 1
let g:vimfiler_safe_mode_by_default = 0
let g:vimfiler_edit_action = "open"


" ===== vimshell.vim =====
if neobundle#tap('vimshell')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    let g:vimshell_user_prompt = 'getcwd()'
    let g:vimshell_prompt = "/ _ / X < "
  endfunction

  nmap <C-@> <Plug>(vimshell_switch)
  nmap <C-Space> <Plug>(vimshell_switch)
  nnoremap ! :VimShellExecute<Space>
endif


" ===== watchdogs.vim =====
let bundle = neobundle#get('vim-watchdogs')
function! bundle.hooks.on_source(bundle)
  let g:watchdogs_check_BufWritePost_enable = 1
  let g:watchdogs_check_BufWritePost_enables = {
  \   "perl": 0,
  \   "zsh": 0,
  \ }

  let g:watchdogs_check_CursorHold_enable = 0

  call watchdogs#setup(g:quickrun_config)
endfunction


" ===== yankround.vim =====
nmap p <Plug>(yankround-p)
nmap P <Plug>(yankround-P)
nmap <C-p> <Plug>(yankround-prev)
nmap <C-n> <Plug>(yankround-next)


" === Other === {{{1
" vim hacks #161
nnoremap <sid>(command-line-enter) q:
xnoremap <sid>(command-line-enter) q:
nnoremap <sid>(command-line-norange) q:<C-u>

nmap :  <sid>(command-line-enter)
xmap :  <sid>(command-line-enter)

Autocmd CmdwinEnter * call s:init_cmdwin()
function! s:init_cmdwin()
  nnoremap <buffer> q :<C-u>quit<CR>
  nnoremap <buffer> <TAB> :<C-u>quit<CR>
  inoremap <buffer> <expr> <CR> pumvisible() ? "\<C-y>\<CR>" : "\<CR>"
  inoremap <buffer> <expr> <C-h> pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"
  inoremap <buffer> <expr> <BS> pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"

  startinsert!
endfunction

" kana's useful tab function {{{
function! s:move_window_into_tab_page(target_tabpagenr)
  " Move the current window into a:target_tabpagenr.
  " If a:target_tabpagenr is 0, move into new tab page.
  if a:target_tabpagenr < 0  " ignore invalid number.
    return
  endif
  let original_tabnr = tabpagenr()
  let target_bufnr = bufnr('')
  let window_view = winsaveview()

  if a:target_tabpagenr == 0
    tabnew
    tabmove  " Move new tabpage at the last.
    execute target_bufnr 'buffer'
    let target_tabpagenr = tabpagenr()
  else
    execute a:target_tabpagenr 'tabnext'
    let target_tabpagenr = a:target_tabpagenr
    topleft new  " FIXME: be customizable?
    execute target_bufnr 'buffer'
  endif
  call winrestview(window_view)

  execute original_tabnr 'tabnext'
  if 1 < winnr('$')
    close
  else
    enew
  endif

  execute target_tabpagenr 'tabnext'
endfunction " }}}
nnoremap <silent> <Space>ao :<C-u>call <SID>move_window_into_tab_page(0)<Cr>


function! ChangeCurrentDirectoryToProjectRoot()
  let directory = unite#util#path2project_directory(expand('%'))
  if isdirectory(directory)
    execute ":lcd " . directory
  endif
endfunction
Autocmd BufEnter * call ChangeCurrentDirectoryToProjectRoot()
